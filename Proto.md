# The protocol

simi protocol implements a secure communication model similar to SSH. Unlike SSH, plain text messages are not only encrypted, but also embedded in .png pictures using LSB (hence the name) and sent along with plain text messages. Here is an example of a typical session:

- Computer A sends computer B a *request* message to establish comunication with A's public key
- Computer B replies with an *accept* message containig: B's public key, a session key (generated by B) and a random number R; the latter two are encrypted with an A's public key
- A replies with a *confirm* message containing the random number, encrypted with B's public key.
- Computer A sends *speak plain* message containing plain text. Since TCP guarantees delivery, no acknowledgement is needed
- Computer B sends *speak* message containing image with a secret message. A extracts the secret and decrypts it using session key
- Computer C sends *request* message to B. Since B has already established a sesssion, it replies to C with *deny* message
- Computer A sends *close* message to B. The session is finished

## Protocol messages

Each protocol message consists of a mandatory `type` field and an optional argument, `data`. Using Rust language notation, the message could be represented as follows:s

```rust

struct Message {
    typ: Type,
    data: Option<[u8; _]>,
}

enum Type {
    Request,
    Accept,
    Deny,
    Confirm,
    Speak,
    SpeakPlain,
    Close,
}

```

## Protocol state table

Each protocol implements a state machine with three states: idle, waiting for `ip:port` and connected to `ip:port`. This state machine may be represented as the following Rust `enum`:

```rust

enum State {
    Idle,
    Waiting(Address),
    Connected(Address),
}

struct Address {
    ip: net::Ip,    // Types for ip and
    port: net::Port,  // port may vary
}

```

Let's describe protocol with a response table, where 
 - messages are sent from address `x`,
 - "*M* -> *A*" stands for "send *M* to address *A*"
 - "=> *S*" means "switch to state *S*"
 - "display" outputs something to user
 - "-" means "ignore"

| Message    | Idle      | Waiting(x)                    | Waiting(y) | Connected(x)     | Connected(y) |
|------------|-----------|-------------------------------|------------|------------------|--------------|
| Request    | Deny -> x | Accept -> x                   | Deny -> x  | -                | Deny -> x    |
| Accept     | -         | => Connected(x), Confirm -> x | -          | -                | -            |
| Confirm    | -         | => Connected(x)               | -          | -                | -            |
| Deny       | -         | display("X is offline")       | -          | -                | -            |
| Speak      | -         | -                             | -          | display(message) | -            |
| SpeakPlain | -         | -                             | -          | display(message) | -            |
| Close      | -         | -                             | -          | => Waiting(x)/-  | -            |

Note that Close accepted only if the number in the message matches one in recipient's memory, otherwise this message is ignored.

Await table. Messages are sent to *x* if otherwise is not stated. Columns for states Connected(y) and Waiting(y) are omitted; the only case when something is sent in these states is denial of connection. This is represented by row "(Deny -> y) ...".

| Message    | Waiting(x)  | Connected(x) |
|------------|-------------|--------------|
| Request    | Accept/Deny | -            |
| Accept     | Confirm     | None         |
| Confirm    | -           | None         |
| Deny -> y  | None        | None         |
| Deny -> x  | -           | -            |
| Speak      | -           | None         |
| SpeakPlain | None        | None         |
| Close      | None        | None         |

Another version of this protocol includes messages for *ACK* and *NACK*: the former is sent after the text from *speak* message has been successfully decrypted, otherwise, *NACK* is sent. We can also send some redundant *NACK*s (crossed out) insead of just ignoring the ill-formed request.

| Message    | Idle      | Waiting(x)                    | Waiting(y) | Connected(x)     | Connected(y) |
|------------|-----------|-------------------------------|------------|------------------|--------------|
| Request    | Deny -> x | Accept -> x                   | Deny -> x  | -                | Deny -> x    |
| Accept     | -         | => Connected(x), Confirm -> x | -          | -                | -            |
| Confirm    | -         | => Connected(x)               | -          | -                | -            |
| Deny       | -         | display("X is offline")       | -          | -                | -            |
| Speak      | Nack -> x | Nack -> x                     | Nack -> x  | decrypt,display()+Ack->X or Nack->x         | Nack -> x    |
| SpeakPlain | Nack -> x | Nack -> x                     | Nack -> x  | display(message) | Nack -> x    |
| Ack        | -         | -                             | -          | display(success) | -            |
| Nack       | -         | -                             | -          | display(failure) | -            |
| Close      | -         | -                             | -          | => Waiting(x)/-  | -            |


Await table for version with *ACK*/*NACK*. Nack and Ack don't require a response being sent to both x and y,
so columns "Connected(y)" and "Waiting(y)" are omitted again.

| Message    | Waiting(x)  | Connected(x) |
|------------|-------------|--------------|
| Request    | Accept/Deny | -            |
| Accept     | -           | None         |
| Confirm    | -           | None         |
| Deny -> y  | None        | None         |
| Deny -> x  | -           | -            |
| Speak      | -           | Ack/Nack     |
| SpeakPlain | None        | None         |
| Ack        | None        | None         |
| Nack       | None        | None         |
| Close      | None        | None         |


